import OpenAI from 'openai';
import chalk from 'chalk';
import type { ParsedFile, AIProvider, DocumentationStyle } from '../types/index.js';

// Define the OpenAI model to use
// You can change this to 'gpt-3.5-turbo' or any other model you prefer
// Note: 'gpt-4o' is a placeholder; replace with the actual model you want to use
// Ensure your OpenAI account has access to the specified model
// as model availability may vary based on your subscription or access level.
// For example, 'gpt-4o' is a model optimized for code understanding and generation.
// If you want to use a different model, change the OPENAI_MODEL constant below.
// For more information on available models, refer to the OpenAI API documentation.
// https://platform.openai.com/docs/models/overview
const OPENAI_MODEL = 'gpt-4o';

const openai = new OpenAI({
  apiKey: process.env.OPENAI_API_KEY || process.env.OPENAI_KEY
});

export async function generateDocumentation(
  parsedFile: ParsedFile,
  aiProvider: AIProvider = 'openai',
  style: DocumentationStyle = 'detailed'
): Promise<string> {
  if (aiProvider === 'ollama') {
    throw new Error('Ollama support is not implemented yet. Please use OpenAI for now.');
  }

  if (!process.env.OPENAI_API_KEY && !process.env.OPENAI_KEY) {
    throw new Error('OpenAI API key not found. Please set OPENAI_API_KEY environment variable.');
  }

  try {
    const prompt = buildPrompt(parsedFile, style);
    
    const response = await openai.chat.completions.create({
      model: OPENAI_MODEL,
      messages: [
        {
          role: 'system',
          content: getSystemPrompt(style)
        },
        {
          role: 'user',
          content: prompt
        }
      ],
      temperature: 0.3, // Lower for more consistent documentation
      max_tokens: 2000,
    });

    const documentation = response.choices[0]?.message?.content;
    
    if (!documentation) {
      throw new Error('No documentation generated by AI');
    }

    return documentation.trim();

  } catch (error) {
    if (error.status === 401) {
      throw new Error('Invalid OpenAI API key. Please check your OPENAI_API_KEY environment variable.');
    }
    if (error.status === 429) {
      throw new Error('OpenAI API rate limit exceeded. Please try again later.');
    }
    if (error.status === 500) {
      throw new Error('OpenAI API server error. Please try again later.');
    }
    
    throw new Error(`OpenAI API error: ${error.message}`);
  }
}

function getSystemPrompt(style: DocumentationStyle): string {
  const basePrompt = `You are an expert technical writer who specializes in creating clear, comprehensive code documentation. Your task is to analyze code structures and generate professional documentation.

Guidelines:
- Write clear, concise explanations that developers can easily understand
- Include parameter descriptions, return values, and usage examples where appropriate
- Use proper markdown formatting
- Focus on what the code does, not how it works internally
- Include any important edge cases or considerations
- Be accurate and avoid speculation`;

  if (style === 'concise') {
    return basePrompt + '\n- Keep explanations brief and to the point\n- Focus on essential information only';
  }

  return basePrompt + '\n- Provide detailed explanations with context\n- Include comprehensive examples and use cases';
}

function buildPrompt(parsedFile: ParsedFile, style: DocumentationStyle): string {
  const { path, language, functions, classes, exports, imports, comments } = parsedFile;

  let prompt = `Please generate ${style} documentation for the following ${language} file: ${path}\n\n`;

  if (imports.length > 0) {
    prompt += `**Imports/Dependencies:**\n${imports.map(imp => `- ${imp}`).join('\n')}\n\n`;
  }

  if (functions.length > 0) {
    prompt += `**Functions:**\n`;
    functions.forEach(func => {
      prompt += `\n### ${func.name}\n`;
      prompt += `- Parameters: ${func.parameters.join(', ') || 'none'}\n`;
      prompt += `- Return type: ${func.returnType || 'unknown'}\n`;
      if (func.docstring) {
        prompt += `- Existing documentation: ${func.docstring}\n`;
      }
      if (func.body) {
        prompt += `- Function body preview: ${func.body.substring(0, 200)}${func.body.length > 200 ? '...' : ''}\n`;
      }
    });
    prompt += '\n';
  }

  if (classes.length > 0) {
    prompt += `**Classes:**\n`;
    classes.forEach(cls => {
      prompt += `\n### ${cls.name}\n`;
      if (cls.methods.length > 0) {
        prompt += `- Methods: ${cls.methods.map(m => m.name).join(', ')}\n`;
      }
      if (cls.docstring) {
        prompt += `- Existing documentation: ${cls.docstring}\n`;
      }
    });
    prompt += '\n';
  }

  if (exports.length > 0) {
    prompt += `**Exports:**\n${exports.map(exp => `- ${exp}`).join('\n')}\n\n`;
  }

  if (comments.length > 0) {
    prompt += `**Existing Comments:**\n${comments.slice(0, 5).map(comment => `- ${comment}`).join('\n')}\n\n`;
  }

  prompt += `Please provide comprehensive documentation in markdown format that explains:
1. Purpose and overview of the file
2. Main functionality and features
3. Usage examples for key functions/classes
4. Important parameters and return values
5. Any notable dependencies or requirements

Format the response as clean markdown suitable for README files or documentation sites.`;

  return prompt;
}

// Retry wrapper for API calls
export async function withRetry<T>(
  operation: () => Promise<T>,
  maxRetries: number = 3,
  delay: number = 1000
): Promise<T> {
  let lastError = new Error('Operation failed');

  for (let attempt = 1; attempt <= maxRetries; attempt++) {
    try {
      return await operation();
    } catch (error) {
      lastError = error;
      
      // Don't retry on authentication errors
      if (error.status === 401) {
        throw error;
      }

      if (attempt < maxRetries) {
        console.log(chalk.yellow(`⚠️  Attempt ${attempt} failed, retrying in ${delay}ms...`));
        await new Promise(resolve => setTimeout(resolve, delay));
        delay *= 2; // Exponential backoff
      }
    }
  }

  throw lastError;
}
