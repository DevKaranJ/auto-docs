import path from 'path';
import fs from 'fs/promises';
import { getOutputFileName, createIndexFile } from './index.js';
import type { DocumentationResult, GenerationOptions, FunctionInfo, ClassInfo } from '../../types/index.js';

export async function generateMarkdown(
  results: DocumentationResult[],
  options: GenerationOptions
): Promise<void> {
  // Generate individual markdown files for each source file
  for (const result of results) {
    const outputFile = getOutputFileName(result.file, 'markdown', options.outputPath);
    const markdownContent = generateMarkdownForFile(result);
    
    await fs.writeFile(outputFile, markdownContent, 'utf-8');
  }

  // Create an index file
  await createIndexFile(results, options);
}

function generateMarkdownForFile(result: DocumentationResult): string {
  const { file, parsedCode, documentation } = result;
  const fileName = path.basename(file);
  const relativePath = path.relative(process.cwd(), file);

  const lines: string[] = [];

  // File header
  lines.push(`# ${documentation.title || fileName}`);
  lines.push('');
  lines.push(`**File:** \`${relativePath}\``);
  lines.push(`**Language:** ${parsedCode.language}`);
  lines.push('');

  // Description
  if (documentation.description) {
    lines.push('## Description');
    lines.push('');
    lines.push(documentation.description);
    lines.push('');
  }

  // Table of Contents
  if (documentation.functions?.length || documentation.classes?.length) {
    lines.push('## Table of Contents');
    lines.push('');

    if (documentation.functions?.length) {
      lines.push('### Functions');
      documentation.functions.forEach(func => {
        lines.push(`- [${func.name}](#${func.name.toLowerCase()})`);
      });
      lines.push('');
    }

    if (documentation.classes?.length) {
      lines.push('### Classes');
      documentation.classes.forEach(cls => {
        lines.push(`- [${cls.name}](#${cls.name.toLowerCase()})`);
      });
      lines.push('');
    }
  }

  // Functions documentation
  if (documentation.functions?.length) {
    lines.push('## Functions');
    lines.push('');

    documentation.functions.forEach(func => {
      lines.push(...generateFunctionMarkdown(func));
      lines.push('');
    });
  }

  // Classes documentation
  if (documentation.classes?.length) {
    lines.push('## Classes');
    lines.push('');

    documentation.classes.forEach(cls => {
      lines.push(...generateClassMarkdown(cls));
      lines.push('');
    });
  }

  // Exports
  if (documentation.exports?.length) {
    lines.push('## Exports');
    lines.push('');

    documentation.exports.forEach(exp => {
      lines.push(`### ${exp.name}`);
      lines.push('');
      lines.push(`**Type:** ${exp.type}`);
      
      if (exp.description) {
        lines.push('');
        lines.push(exp.description);
      }
      
      lines.push('');
    });
  }

  // Usage section
  if (documentation.usage) {
    lines.push('## Usage');
    lines.push('');
    lines.push(documentation.usage);
    lines.push('');
  }

  // Notes section
  if (documentation.notes) {
    lines.push('## Notes');
    lines.push('');
    lines.push(documentation.notes);
    lines.push('');
  }

  // Footer
  lines.push('---');
  lines.push('');
  lines.push(`*Generated by Auto-Docs on ${new Date().toLocaleDateString()}*`);

  return lines.join('\n');
}

function generateFunctionMarkdown(func: any): string[] {
  const lines: string[] = [];

  lines.push(`### ${func.name}`);
  lines.push('');

  if (func.description) {
    lines.push(func.description);
    lines.push('');
  }

  // Function signature
  const params = func.parameters?.map((p: any) => 
    `${p.name}${p.type !== 'any' ? `: ${p.type}` : ''}${p.defaultValue ? ` = ${p.defaultValue}` : ''}`
  ).join(', ') || '';
  
  const returnType = func.returns?.type !== 'any' ? ` -> ${func.returns.type}` : '';
  
  lines.push('**Signature:**');
  lines.push(`\`\`\`${getLanguageForSignature()}`);
  lines.push(`${func.name}(${params})${returnType}`);
  lines.push('```');
  lines.push('');

  // Parameters
  if (func.parameters?.length) {
    lines.push('**Parameters:**');
    lines.push('');
    
    func.parameters.forEach((param: any) => {
      lines.push(`- **${param.name}** \`${param.type}\` - ${param.description || 'No description'}`);
      if (param.defaultValue) {
        lines.push(`  - Default: \`${param.defaultValue}\``);
      }
    });
    lines.push('');
  }

  // Returns
  if (func.returns && func.returns.type !== 'void') {
    lines.push('**Returns:**');
    lines.push('');
    lines.push(`- \`${func.returns.type}\` - ${func.returns.description || 'No description'}`);
    lines.push('');
  }

  // Example
  if (func.example) {
    lines.push('**Example:**');
    lines.push('');
    lines.push('```javascript');
    lines.push(func.example);
    lines.push('```');
    lines.push('');
  }

  return lines;
}

function generateClassMarkdown(cls: any): string[] {
  const lines: string[] = [];

  lines.push(`### ${cls.name}`);
  lines.push('');

  if (cls.description) {
    lines.push(cls.description);
    lines.push('');
  }

  // Properties
  if (cls.properties?.length) {
    lines.push('**Properties:**');
    lines.push('');
    
    cls.properties.forEach((prop: any) => {
      const optional = prop.optional ? ' (optional)' : '';
      const visibility = prop.visibility ? `${prop.visibility} ` : '';
      lines.push(`- **${visibility}${prop.name}** \`${prop.type}\`${optional} - ${prop.description || 'No description'}`);
    });
    lines.push('');
  }

  // Constructor
  if (cls.constructor) {
    lines.push('**Constructor:**');
    lines.push('');
    lines.push(...generateFunctionMarkdown(cls.constructor));
  }

  // Methods
  if (cls.methods?.length) {
    lines.push('**Methods:**');
    lines.push('');
    
    cls.methods.forEach((method: any) => {
      lines.push(`#### ${method.name}`);
      lines.push('');
      lines.push(...generateFunctionMarkdown(method).slice(2)); // Skip the method name header
    });
  }

  return lines;
}

function getLanguageForSignature(): string {
  // This could be dynamically determined based on the file being processed
  return 'javascript';
}
